---
title: "Statistical Analysis: Modelling the Effect of Communicative Attempt (H1) and Answer Similarity (H2) on Effort"
format:
  html:
    code-overflow: wrap
    code-width: 1200  # Adjust the width in pixels
execute:
   warning: false 
---

# Overview {#sec-stats}

In this script, we will be modelling the causal relation between effort and correction to confirm/reject our hypothesis.

These are:

H1: In corrections, people enhance some effort-related kinematic and/or acoustic features of their behaviour relative to the baseline.

H2: The enhancement depends on similarity of the guesser's answer and the original meaning. More similar answer will require/result in smaller enhancement (but still enhancement) than less similar answer.

To assess the design and performance of the model, we will use synthetic data that we create to have certain interdependencies and where the effects have pre-defined values. We use this approach instead of using our dyad 0 data, because the pilot data do not include enough data to have a sensible testing sample.

The confirmatory analysis concerns six outcome variables, namely integral of torque change, integral of amplitude envelope, integral of change in center of pressure, and mean peak value of torque change, mean peak value of amplitude envelope, and mean peak value of change in center of pressure. For our exploratory analysis, we will model variables that will result as most predictive in relation to communicative attempt, assessed by XGBoost modelling (in the previous script @sec-xgboost). This is why in our synthetic data, we create a variable Effort that is continuous, but oterwise free of any other assumptions.

```{r setup environment, echo=TRUE, message=FALSE, warning=FALSE}
#| code-fold: true
#| code-summary: Code to prepare the environment

library(here)
library(dplyr) # for data-wrangling
library(tidyr)  # for reshaping data (if needed)
library(ggplot2)
library(tibble)
library(rcartocolor)
library(patchwork)

library(ggdag) # for dag
library(dagitty)

library(bayesplot) # bayesian stuff
library(brms)
library(beepr)
library(bayestestR)
library(tidyverse)

library(splines) # for bsplines
library(emmeans) # for lognormal transformations


# current folder (first go to session -> set working directory -> to source file location)
curfolder <- getwd()
parentfolder <- dirname(curfolder)

featurefolder <- paste0(parentfolder, '/07_TS_featureExtraction/Datasets/')
demofolder    <- paste0(parentfolder, '/00_RAWDATA/Demographics_all/')
datasets      <- paste0(curfolder, '/datasets/')
models        <- paste0(curfolder, '/models/')
plots         <- paste0(curfolder, '/plots/')


```

# Loading in our data

This is the feature dataframe we will be using when having access to full data. Additionally, we will merge the feature dataframe with demographic data collected via Qualtrics.

```{r loading data, echo=TRUE, message=FALSE, warning=FALSE}

data_feat <- read_csv(paste0(featurefolder, "features_df_final.csv"))
data_demo <- read_csv(paste0(demofolder, "all_demodata.csv"))

```

For confirmatory analysis, we will need only 6 features - arm torque integral, arm torque peak mean, COPc integral, COPc peak mean, envelope integral and envelope peak mean from the data_feat. From data_demo, we will need only BFI and Familiarity

```{r}

featstokeep <- c('COPc_pospeak_mean', 'envelope_pospeak_mean', 'arm_moment_sum_change_pospeak_mean', 'COPc_integral', 'envelope_integral', 'arm_moment_sum_change_integral', 'correction_info', 'concept', 'TrialID', 'modality', 'expressibility', 'answer_prev', 'answer_prev_dist')

demotokeep <- c('BFI_extra', 'BFI_agree', 'BFI_consc', 'BFI_negemo', 'BFI_open', 'Familiarity', 'pcn_ID')

# Subset the dataframe
data_feat <- data_feat %>% select(all_of(featstokeep))
data_demo <- data_demo %>% select(all_of(demotokeep))

```

To merge them, we will need to have column pcn_ID in data_feat too.

```{r}

# Extract participant part from TrialID
data_feat <- data_feat %>%
  mutate(
    pcn_ID = str_extract(TrialID, "^[0-9]+") %>%  # Extract first number (before first underscore)
      paste0("_", str_extract(TrialID, "p[0-9]+") %>% str_remove("p")) # Extract last part and format as pcn_ID
  )

final_data <- left_join(data_feat, data_demo, by = "pcn_ID")

head(final_data, n=15)
```

Because current pilot data are quite likely unsufficient in terms of power (65 observations), and would hinder testing the design of the statistical models, we will create synthetic data with assumed coefficients for all predictors we plan to add to the model.

# H1: Stating causal model

Before simulating synthetic data, we will first formulate our causal model to explicitly identify common causes, and hence prevent (or rather minimize) confounding in our statistical model. Note that while we are interested in causal relationship between effort (outcome) and communicative attempt (predictor for H1) and answer similarity (predictor for H2), we need to acknowledge that there are other factors possibly contributing to the outcome variable, despite the experiment beling relatively controlled. These relate, for instance, to the participants (e.g., personality traits) or stimuli (i.e., concepts). Our causal model therefore includes more variables that are identified as potentially sharing causal path with our primary predictor - communicative attempt. They are not of primary interest, they ensure we can isolate the causal effect of the main predictor on the outcome variable - effort.

To explicitly formulate the causal paths, we will start our analysis visualizing our causal model using directed acyclic graph (DAG). We will use packages `dagitty` and `ggdag` to create these DAGs and to extract implied independencies and adjustment set. DAG will help us clarify the causal model and introduce the predictors we aim to model (@McElreath). This model goes hand in hand with the logic underlying the synthetic data we create below.

Our first hypothesis goes as follows:

*H1: Correction recruits more physical effort than the baseline performance.*

The relationship of interest is the causal effect of *communicative attempt* on *effort*. Further, our causal model includes following assumptions:

-   Personality traits (measured with Big5) will influence effort (e.g., people are more willing to put more effort if they are open-minded) and also communicative attempt (e.g., more extroverted people are better in this game, therefore they need less attempts)

-   Familiarity with guessing partner influences effort (ditto) as well as communicative attempt (e.g., friends are better in this game than strangers)

-   Similarly, participant will also directly influence effort and commAtt, because personality traits might not be capturing all variation

-   Expressibility of concepts is going to influence effort (e.g., more expressible concepts allow more enhancement - but could be also other direction) as well as CommAtt (e.g., more expressible concepts are more readily guessed and don't need more attempts)

-   Similarly, concept will also directly influence effort and commAtt, because expressibility might not be capturing all variation

-   Modality (uni vs. multi) will influence the value of effort. We assume that in unimodal condition, the feature does not need to account for synergic relations with the other modality, and may carry the whole signal. In multimodal condition, however, there may be synergic relations that moderate the full expressiveness of this feature

-   Trial number (characterising how far one is in the experiment) could be hinting on learning processes through out the experiment, or - the other direction - on increasing fatigue

```{r dag h1, echo=FALSE, message=FALSE, warning=FALSE}

daggy_h1 <- dagitty('dag {
Big5 [adjusted,pos="-1.5,1"]
CommAtt [exposure,pos="-2,0"]
Conc [adjusted,pos="-2,-1.5"]
Eff [outcome,pos="0,0"]
Expr [adjusted,pos="-1.5,-1.5"]
Fam [adjusted,pos="-0.5,1"]
Pcn [adjusted,pos="-1,2"]
TrNum [adjusted,pos="-2.5,-1.5"]
Mod [adjusted,pos="0.5,0.5"]

Big5 -> CommAtt     
Big5 -> Eff
CommAtt -> Eff
Conc -> Expr
Expr -> CommAtt
Expr -> Eff
Fam -> CommAtt
Fam -> Eff
Mod -> Eff
Mod -> CommAtt
Pcn -> Big5
Pcn -> CommAtt 
Pcn -> Eff
Pcn -> Fam
TrNum -> CommAtt
TrNum -> Eff
Conc -> CommAtt
Conc -> Eff
}')

# Use ggdag for a cleaner visualization
d1 <- ggdag(daggy_h1, text = TRUE, use_labels = "name") +
  theme_dag() +
  ggtitle("Causal DAG for H1") +
  theme(plot.title = element_text(hjust = 0.5))

d1

```

These are the implied conditional independencies

```{r dag h1 independencies, echo=FALSE, message=FALSE, warning=FALSE}

impliedConditionalIndependencies(daggy_h1)

```

This is the adjustment set that needs to be included in the model to make sure we are not confounding

```{r dag h1 adjustset, echo=FALSE, message=FALSE, warning=FALSE}

dagitty::adjustmentSets(daggy_h1, exposure = "CommAtt", outcome = "Eff")

```

# Creating synthetic data (for pre-registration purposes only)

Now we can proceed with creating synthetic data, incorporating the relationships we have acknowledged in our causal model. We will then use these data to validate the statistical models. Following McElreath (@ADDREF), we believe this approach constitutes a principled and transparent method for model validation. By evaluating the model structure on simulated data before fitting it to empirical observations, we reduce the risk of overfitting and p-hacking, as model assumptions and inferences are tested independently of the observed data.

Note that the synthetic data do not copy the structure of the data and the experimental design perfectly, but they do provide a reliable ground to build the models and test their performance.

```{r synthetic data, echo=TRUE, message=FALSE, warning=FALSE}

# Set seed for reproducibility
set.seed(0209)

# Set coefficients
b_exp_vocal <- 0.6  # Vocal has lower expressibility
b_exp_multi <- 1.5  # Multimodal has higher expressibility
b_bif <- 1.15  # More extroverted → more effort
b_fam <- 1.10  # More familiarity → more effort
b_exp <- 1.20  # More expressibility → more effort
b_multi <- 0.70  # Multimodal → slightly reduced effort
b_comatt2 <- 1.50  # Effort increases for second attempt
b_comatt3 <- 0.50  # Effort decreases for third attempt
b_prevan <- 0.50  # Higher previous answer similarity → less effort

# Define participants and concepts
n_participants <- 120
n_total_concepts <- 21  # Each participant works with all 21 concepts
n_modalities <- 3  # Gesture, vocal, combined

# Generate participant-level data
participants <- 1:n_participants
Big5 <- runif(n_participants, min = 0, max = 2)
Familiarity <- runif(n_participants, min = 0, max = 2)

# Generate expressibility scores for each concept across modalities
expressibility_matrix <- matrix(runif(n_total_concepts * n_modalities, min = 0, max = 1),
                                nrow = n_total_concepts, ncol = n_modalities)

# Initialize data storage
final_data_synt <- data.frame()

# Define function to simulate participant data
simulate_participant <- function(participant_id) {
  participant_data <- data.frame()
  trial_number <- 1
  
  for (concept_id in 1:n_total_concepts) {
    # Assign a random modality
    modality <- sample(c("gesture", "vocal", "combined"), 1)
    
    # Get expressibility score based on modality
    expressibility_score <- ifelse(modality == "vocal", expressibility_matrix[concept_id, 1] * b_exp_vocal, 
                                   ifelse(modality == "gesture", expressibility_matrix[concept_id, 2], 
                                          expressibility_matrix[concept_id, 3] * b_exp_multi))
    
    # Base effort before adjustments
    base_effort <- b_bif * Big5[participant_id] + 
                   b_fam * Familiarity[participant_id] + 
                   b_exp * expressibility_score + 
                   rnorm(1, mean = 1, sd = 0.5)
    
    # Adjust effort for multimodal condition
    if (modality == "combined") {
      base_effort <- base_effort * b_multi
    }
    
    # Sample the number of communicative attempts (CommAtt)
    adjusted_prob <- c(1 - Familiarity[participant_id],
                       1 - Familiarity[participant_id],
                       1 - Familiarity[participant_id]) * 
                     c(1 - Big5[participant_id],
                       1 - Big5[participant_id],
                       1 - Big5[participant_id]) * 
                     c(1 - expressibility_score,
                       1 - expressibility_score,
                       1 - expressibility_score)
    
    adjusted_prob <- adjusted_prob / sum(adjusted_prob)
    n_attempts <- sample(1:3, 1, prob = adjusted_prob)
    
    prev_answer_similarity <- NA  # First attempt has no previous similarity
    
    # Generate rows for each communicative attempt
    for (attempt in 1:n_attempts) {
      Eff <- base_effort  # Start with base effort
      
      # Modify effort for second and third attempts
      if (attempt == 2) {
        Eff <- Eff * b_comatt2
      } else if (attempt == 3) {
        Eff <- Eff * b_comatt3
      }
      
      # Adjust effort based on previous answer similarity
      if (!is.na(prev_answer_similarity)) {
        Eff <- Eff * (1 + (1 - prev_answer_similarity) * b_prevan)
      }
      
      # Store row
      participant_data <- rbind(participant_data, data.frame(
        Participant = participant_id,
        Concept = concept_id,
        Modality = modality,
        Big5 = Big5[participant_id],
        Familiarity = Familiarity[participant_id],
        Expressibility = expressibility_score,
        CommAtt = attempt,
        Eff = Eff,
        TrialNumber = trial_number,
        PrevAn = prev_answer_similarity
      ))
      
      # Update for next attempt
      trial_number <- trial_number + 1
      prev_answer_similarity <- runif(1, min = 0, max = 1)  # Simulate next similarity
    }
  }
  
  return(participant_data)
}

# Simulate data for all participants
final_data_synt <- do.call(rbind, lapply(participants, simulate_participant))

# Preview results
head(final_data_synt, n=15)

```

# Exploring the synthetic data

This is the distribution of our simulated effort feature

```{r effort hist, echo=FALSE, message=FALSE, warning=FALSE}

hist(final_data_synt$Eff, breaks=100)
```

This is the relationship between effort and communicative attempt (H1) as seen in the raw (synthetic) data

```{r h1 raw plot, echo=FALSE, message=FALSE, warning=FALSE}

# Create a boxplot comparing Effort across different Communicative Attempts
ggplot(final_data_synt, aes(x = as.factor(CommAtt), y = Eff)) +
  geom_boxplot(aes(fill = as.factor(CommAtt))) +  
  labs(title = "Comparison of Effort Across Communicative Attempts",
       x = "Communicative Attempts",
       y = "Effort",
       fill = "CommAtt") + 
  theme_minimal() +
  theme(legend.position = "none")  

```

```{r save data, include=FALSE, message=FALSE, warning=FALSE, include=FALSE}

# Save the synthetic data for future purposes

write.csv(final_data_synt, file = here("09_Analysis_Modeling", "datasets", "synthetic_data.csv"), row.names = FALSE)

```

# H1: Modelling

In this part, we are going to test the following hypothesis:

*H1: Correction recruits more physical effort than the baseline performance.*

```{r cores, include=FALSE, message=FALSE, warning=FALSE}

# use all available cores for parallel computing
options(mc.cores = parallel::detectCores())
```

## Data wrangling

To be able to interpret the data, we will first need to do some data wrangling

```{r load data1, include=FALSE, message=FALSE, warning=FALSE, include=FALSE}

final_data <- read_csv(paste0(datasets, "synthetic_data.csv"))
```

Convert columns to factors

```{r h1 factorizing, message=FALSE, warning=FALSE}

final_data$CommAtt <- as.factor(final_data$CommAtt)
final_data$Modality <- as.factor(final_data$Modality)
final_data$Participant <- as.factor(final_data$Participant)
final_data$Concept <- as.factor(final_data$Concept)

final_data$TrialNumber <- as.numeric(final_data$TrialNumber)  # Ensure TrialNumber is numeric
```

Contrast-coding of categorical variables

```{r h1 contrast coding, message=FALSE, warning=FALSE}

contrasts(final_data$CommAtt) <- MASS::contr.sdif(3)
contrasts(final_data$Modality) <- contr.sum(3)/2
```

::: callout-note
This is how CommAtt is contrast-coded now

2-1 3-2

1 -0.6666667 -0.3333333 2 0.3333333 -0.3333333 3 0.3333333 0.6666667

This is how modality is cc-ed

\[,1\] \[,2\]

combined 0.5 0.0 gesture 0.0 0.5 vocal -0.5 -0.5
:::

Centering continuous variables

```{r h1 centering, message=FALSE, warning=FALSE}

final_data$TrialNumber_c <- final_data$TrialNumber - median(range(final_data$TrialNumber))
final_data$Familiarity <- final_data$Familiarity - median(range(final_data$Familiarity))
final_data$Big5 <- final_data$Big5 - median(range(final_data$Big5))
# For now, we will just center Familiarity and Big5 because we created them synthetically. But the real data have these two variables already z-scored

```

Z-scoring expressibility within a modality

```{r h1 zscoring, message=FALSE, warning=FALSE}

final_data <-
  final_data |>
  group_by(Modality) |>
  mutate(Expressibility_z = (Expressibility - mean(Expressibility))/ sd(final_data$Expressibility, na.rm = T)) |>
  ungroup()

```

## Model 1 - Simple reproduction of DAG

First we want to do a simple model that reproduce our DAG.

Our main predictor is communicative attempt (CommAtt). To account for confounders - variables affecting both the predictor and the dependent variable - we need to adjust for them in the model by including them as covariates to isolate the effect of the predictor. Based on our DAG, confounders include:

1.  familiarity
2.  big5
3.  expressibility
4.  trial number
5.  modality
6.  concept
7.  participant

We include 1.-5. as fixed factors. For 6.-7., we include varying intercepts as we expect that each participant and concept may have they own baseline level of effort and thus allow for individual variation. Partial pooling is also beneficial in that extreme values (or categories will fewer datapoints) will be shrunk toward the overal average.

We will now not include PrevAn (previous answer) variable because we will need to do some further data-wrangling when building model for H2. That is mainly because PrevAn has some NA values, concretely for first attempts. Models would automatically exclude NA data, and we would therefore loose all effort data for attempt 1. For H1, however, we want to keep it there.

This is our first model without setting any priors, leaving them to default values

```{r h1.m1 model, eval=FALSE, message=FALSE, warning=FALSE}

h1.m1 <- brm(Eff ~ 1 + CommAtt + Familiarity + Big5 + Expressibility_z + TrialNumber_c + Modality + (1 | Participant) + (1 | Concept),
                data = final_data,
                iter = 4000,
                cores = 4)

# Add criterions for later diagnostics
h1.m1 <- add_criterion(h1.m1, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h1.m1_R2 <- bayes_R2(h1.m1)

# Save both as objects
saveRDS(h1.m1, here("09_Analysis_Modeling", "models", "h1.m1.rds"))
saveRDS(h1.m1_R2, here("09_Analysis_Modeling", "models", "h1.m1_R2.rds"))

beep(5)

```

```{r h1.m1 sum, echo=TRUE, message=FALSE, warning=FALSE}

h1.m1 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m1.rds"))
h1.m1_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m1_R2.rds"))


# Summary
summary(h1.m1)

```

::: callout-note
Note on modality: Modality1 represents the baseline difference between combined and the other modalities, and Modality2 represents the difference between gesture and vocal compared to combined.
:::

### Transforming coefficients

To be able to link these estimates back to the simulation coefficients, let's create a function

```{r h1.m1 convert, echo=TRUE, message=FALSE, warning=FALSE}

transform_attempt <- function(intercept, CommAtt2M1, CommAtt3M2) {
  # Effort for the first attempt (base effort)
  Eff_attempt_1 <- intercept
  
  # Effort for the second attempt
  Eff_attempt_2 <- Eff_attempt_1 + CommAtt2M1
  
  # Effort for the third attempt
  Eff_attempt_3 <- Eff_attempt_1 + CommAtt2M1 + CommAtt3M2
  
  # Calculate ratios
  b_attempt2 <- Eff_attempt_2 / Eff_attempt_1
  b_attempt3 <- Eff_attempt_3 / Eff_attempt_2
  
  return(data.frame(b_attempt2, b_attempt3))
}

h1m1_coeff <- transform_attempt(4.02, 3.08, -4.39)
print(h1m1_coeff)

# For centered familiarity
fam = (4.02 + 1.26) / 4.02
print(fam)

# For centered BIF
bif = (4.02 + 1.29) / 4.02
print(bif)

```

::: callout-note
Expressibility is z-scored so we will not get to the coefficient in the same way but we can check the conditinal effects for checking whether it looks good
:::

Let's also check the visuals

```{r h1.m1 check, echo=TRUE, message=FALSE, warning=FALSE}

plot(h1.m1)
# all caterpillars look nice

plot(conditional_effects(h1.m1), points = TRUE)
# the effects all go in good direction

pp_check(h1.m1, type = "dens_overlay")
# Looks good but not amazing - mostly because the posteriors seem to not know effort cannot be negative

pp_check(h1.m1, type = "error_scatter_avg")
# half blobby, half correlated, so still some room for improvement
# positive correlation means that errors increase with predicted values. So the model does perform well for some range, but becomes less reliable with increase in the predicted values
# also the blob is centered around 0 which is good
# it could be we are ignoring some interaction terms or non-linearity (which we know we kind of do). Transformation could also help (e.g., log). Of course, we are also still not specifying any priors so let's not yet make it a disaster

h1.m1_R2
# explained variance around 83%

```

Overall, we see good directions of all predictors, mostly also in accordance with the expected coefficients. Of course, the synthetic data is quite complex so there might be other dependencies that moderate the causal relationships and that is why we do not see exactly the numbers we use to create the data.

Let's have another model for comparison.

We can assume that participants and concept have not only different baselines of effort (varying intercept). The effect of CommAtt on effort might vary across them too, hence we can try to add varying slopes for them and see whether the diagnostics improves. We will also add TrialNumber as a varying intercept, because we expect variation between earlier and later performances (because of learning, or opposite, fatigue).

## Model 2 - Varying slopes and intercepts

```{r h1.m2 run, eval=FALSE, message=FALSE, warning=FALSE}

h1.m2 <- brm(Eff ~ 1 + CommAtt + Modality + Big5 + Familiarity + Expressibility_z +  (1 + CommAtt | Participant) + (1 + CommAtt | Concept) + (1 | TrialNumber_c), 
                data = final_data,
                iter = 4000,
                cores = 4)

# Add criterions for later diagnostics
h1.m2 <- add_criterion(h1.m2, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h1.m2_R2 <- bayes_R2(h1.m2)

# Save both as objects
saveRDS(h1.m2, here("09_Analysis_Modeling", "models", "h1.m2.rds"))
saveRDS(h1.m2_R2, here("09_Analysis_Modeling", "models", "h1.m2_R2.rds"))

beep(5)

```

```{r h1.m2 sum, message=FALSE, warning=FALSE}

h1.m2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m2.rds"))
h1.m2_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m2_R2.rds"))

# Summary
summary(h1.m2)
# Coefficients remain mostly unchanged but there were some divergent transitions

```

```{r h1.m2 check, message=FALSE, warning=FALSE}

plot(h1.m2)
# some some of the caterpillars are not that pretty anymore

plot(conditional_effects(h1.m2), points = TRUE)
# the effects all go in good direction

pp_check(h1.m2, type = "dens_overlay")
# Looks good but not amazing - mostly because the posteriors seem to not know effort cannot be negative

pp_check(h1.m2, type = "error_scatter_avg")
# This looks a bit more blobby than before but still lots of errors for higher values

h1.m2_R2
# explained variance around 87%

```

One of the reasons why we might be getting the divergent transition is because of the correlation between slopes and intercepts in the previous model. Let's now get rid of it

## Model 3 - No correlation coefficient

```{r h1.m3 run, eval=FALSE, message=FALSE, warning=FALSE}

h1.m3 <- brm(Eff ~ 1 + CommAtt + Modality + Big5 + Familiarity + Expressibility_z +  (1 + CommAtt || Participant) + (1 + CommAtt || Concept) + (1 || TrialNumber_c), 
                data = final_data,
                iter = 4000,
                cores = 4)
                
# Add criterions for later diagnostics
h1.m3 <- add_criterion(h1.m3, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h1.m3_R2 <- bayes_R2(h1.m3)

# Save both as objects
saveRDS(h1.m3, here("09_Analysis_Modeling", "models", "h1.m3.rds"))
saveRDS(h1.m3_R2, here("09_Analysis_Modeling", "models", "h1.m3_R2.rds"))

beep(5)

```

```{r h1.m3 sum, message=FALSE, warning=FALSE}

h1.m3 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m3.rds"))
h1.m3_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m3_R2.rds"))

# Summary
summary(h1.m3)
# Coefficients remain mostly unchanged 


```

```{r h1.m3 check, message=FALSE, warning=FALSE}

plot(h1.m3)
# no correlation fixed the performance

plot(conditional_effects(h1.m3), points = TRUE)
# the effects all go in good direction

pp_check(h1.m3, type = "dens_overlay")
# the problem with predicting negative values remains

pp_check(h1.m3, type = "error_scatter_avg")
# unchanged

h1.m3_R2
# explained variance remains around 87%

```

## Model 3.1 - adding priors

Now we will add some minimal priors, giving the model some reasonably informative, yet weak information.

```{r h1.m3p run, eval=FALSE, message=FALSE, warning=FALSE}

priors_h1m3p <- c(
  set_prior("normal(2.5, 0.5)", class = "Intercept", lb=0),
  set_prior("normal(0,0.50)", class = "b", coef = "CommAtt2M1"),
  set_prior("normal(0,0.50)", class = "b", coef = "CommAtt3M2"),
  set_prior("normal(0,0.25)", class = "b", coef = "Modality1"),
  set_prior("normal(0,0.25)", class = "b", coef = "Modality2"),
  set_prior("normal(0,0.25)", class = "b", coef = "Big5"),
  set_prior("normal(0,0.25)", class = "b", coef = "Familiarity"),
  set_prior("normal(0,0.25)", class = "b", coef = "Expressibility_z"),
  
  set_prior("normal(0.5,0.1)", class = "sd", group = "TrialNumber_c"),
  set_prior("normal(0.5,0.1)", class = "sd", group = "Participant"),
  set_prior("normal(0.5,0.1)", class = "sd", group = "Concept"),
  set_prior("normal(1,0.1)", class = "sd"),
  
  set_prior("normal(0.5,0.25)", class = "sigma")
  
)

h1.m3p <- brm(Eff ~ 1 + CommAtt + Modality + Big5 + Familiarity + Expressibility_z +  (1 + CommAtt || Participant) + (1 + CommAtt || Concept) + (1 || TrialNumber_c), 
                data = final_data,
                prior=priors_h1m3p,
                family = gaussian,
                iter = 4000,
                cores = 4)


# Add criterions for later diagnostics
h1.m3p <- add_criterion(h1.m3p, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h1.m3p_R2 <- bayes_R2(h1.m3p)

# Save both as objects
saveRDS(h1.m3p, here("09_Analysis_Modeling", "models", "h1.m3p.rds"))
saveRDS(h1.m3p_R2, here("09_Analysis_Modeling", "models", "h1.m3p_R2.rds"))

beep(5)

```

```{r h1.m3p sum, message=FALSE, warning=FALSE}


h1.m3p <- readRDS(here("09_Analysis_Modeling", "models", "h1.m3p.rds"))
h1.m3p_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m3p_R2.rds"))


# Summary
summary(h1.m3p)
# Coefficients remain mostly unchanged 


```

```{r h1.m3p check, message=FALSE, warning=FALSE}

plot(h1.m3p)
# all good

plot(conditional_effects(h1.m3p), points = TRUE)
# the effects all go in good direction

pp_check(h1.m3p, type = "dens_overlay")
# the problem with predicting negative values remains

pp_check(h1.m3p, type = "error_scatter_avg")
# unchanged

h1.m3p_R2
# explained variance remains around 87%

```

## Model 4 - Restricting priors with exponential distribution

Let's do one more test with the priors, restricting sd them with exponential distribution, i.e., negative values are not possible

```{r h1.m4 run, eval=FALSE, message=FALSE, warning=FALSE}

priors_h1m4 <- c(
  set_prior("normal(3, 0.3)", class = "Intercept", lb = 0),
  set_prior("normal(0, 0.25)", class = "b", coef = "CommAtt2M1"),
  set_prior("normal(0, 0.25)", class = "b", coef = "CommAtt3M2"),
  set_prior("normal(0, 0.15)", class = "b", coef = "Modality1"),
  set_prior("normal(0, 0.15)", class = "b", coef = "Modality2"),
  set_prior("normal(0, 0.15)", class = "b", coef = "Big5"),
  set_prior("normal(0, 0.15)", class = "b", coef = "Familiarity"),
  set_prior("normal(0, 0.15)", class = "b", coef = "Expressibility_z"),

  # Exponential priors for standard deviations
  set_prior("exponential(3)", class = "sd", group = "TrialNumber_c"), # exp(3) has a mean of 1/3 and concentrates most density around small values
  set_prior("exponential(3)", class = "sd", group = "Participant"),
  set_prior("exponential(3)", class = "sd", group = "Concept"),
  set_prior("exponential(1)", class = "sd"),  # Generic sd prior

  # Residual standard deviation - keep it narrow
  set_prior("normal(0.5, 0.1)", class = "sigma")
)

h1.m4 <- brm(Eff ~ 1 + CommAtt + Modality + Big5 + Familiarity + Expressibility_z +  (1 + CommAtt || Participant) + (1 + CommAtt || Concept) + (1 || TrialNumber_c), 
                data = final_data,
                prior=priors_h1m4,
                family = gaussian,
                iter = 4000,
                cores = 4)


# Add criterions for later diagnostics
h1.m4 <- add_criterion(h1.m4, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h1.m4_R2 <- bayes_R2(h1.m4)

# Save both as objects
saveRDS(h1.m4, here("09_Analysis_Modeling", "models", "h1.m4.rds"))
saveRDS(h1.m4_R2, here("09_Analysis_Modeling", "models", "h1.m4_R2.rds"))

beep(5)

```

```{r h1.m4 sum, message=FALSE, warning=FALSE}


h1.m4 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m4.rds"))
h1.m4_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m4_R2.rds"))


# Summary
summary(h1.m4)
# the coefficients for commatt now seem much lower


```

```{r h1.m4 coeff, message=FALSE, warning=FALSE}


h1m1_coeff <- transform_attempt(4.02, 0.88, -0.36)
print(h1m1_coeff)

# For centered familiarity
fam = (4.02 + 1.17) / 4.02
print(fam)

# For centered BIF
bif = (4.02 + 1.21) / 4.02
print(bif)

```

So it seems that we are misleading with the priors and this will not be the way

```{r h1.m4 check, message=FALSE, warning=FALSE}

plot(h1.m4)
# all good

plot(conditional_effects(h1.m4), points = TRUE)
# the effect of main predictor is now very moderated 

pp_check(h1.m4, type = "dens_overlay")
# the problem with predicting negative values remains

pp_check(h1.m4, type = "error_scatter_avg")
# unchanged

h1.m4_R2
# explained variance remains around 87%

```

## Model 5 - student family

We still see negative values in the posterior simulations, so let's try Student's t-distribution which is more robust to outliers and can potentially reduce the likelihood of negative values (if we reduce degrees of freedom)

```{r h1.m5 run, eval=FALSE, message=FALSE, warning=FALSE}

priors_h1m5 <- c(
  set_prior("normal(2.5, 0.5)", class = "Intercept", lb=0),
  set_prior("normal(0,0.50)", class = "b", coef = "CommAtt2M1"),
  set_prior("normal(0,0.50)", class = "b", coef = "CommAtt3M2"),
  set_prior("normal(0,0.25)", class = "b", coef = "Modality1"),
  set_prior("normal(0,0.25)", class = "b", coef = "Modality2"),
  set_prior("normal(0,0.25)", class = "b", coef = "Big5"),
  set_prior("normal(0,0.25)", class = "b", coef = "Familiarity"),
  set_prior("normal(0,0.25)", class = "b", coef = "Expressibility_z"),
  
  set_prior("normal(0.5,0.05)", class = "sd", group = "TrialNumber_c"),
  set_prior("normal(0.5,0.05)", class = "sd", group = "Participant"),
  set_prior("normal(0.5,0.05)", class = "sd", group = "Concept"),
  set_prior("normal(1,0.05)", class = "sd"),
  
  set_prior("normal(0.5,0.1)", class = "sigma"),
  set_prior("gamma(2, 0.1)", class = "nu")  # Prior for degrees of freedom
  
)

h1.m5 <- brm(Eff ~ 1 + CommAtt + Modality + Big5 + Familiarity + Expressibility_z +  (1 + CommAtt || Participant) + (1 + CommAtt || Concept) + (1 || TrialNumber_c), 
                data = final_data,
                prior=priors_h1m5,
                family = student,
                iter = 4000,
                cores = 4)


# Add criterions for later diagnostics
h1.m5 <- add_criterion(h1.m5, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h1.m5_R2 <- bayes_R2(h1.m5)

# Save both as objects
saveRDS(h1.m5, here("09_Analysis_Modeling", "models", "h1.m5.rds"))
saveRDS(h1.m5_R2, here("09_Analysis_Modeling", "models", "h1.m5_R2.rds"))

beep(5)


```

```{r h1.m5 sum, message=FALSE, warning=FALSE}


h1.m5 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m5.rds"))
h1.m5_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m5_R2.rds"))


# Summary
summary(h1.m5)
# the coefficients look ok again. Familiarity and Big5 even got closer to our simulated betas


```

```{r h1.m5 check, message=FALSE, warning=FALSE}

plot(h1.m5)
# all good

plot(conditional_effects(h1.m5), points = TRUE)
# the effects all go in good direction

pp_check(h1.m5, type = "dens_overlay")
# the fit seems somewhat better than with gaussian, but still negative values are there

pp_check(h1.m5, type = "error_scatter_avg")
# unchanged

h1.m5_R2
# explained variance remains around 85%

```

## Model 6 - log-normal distribution

We have already seen - when plotting - that effort probably tends towards lognormal distribution. We will keep the model constant, just exchange the distribution. Priors are kept default

```{r h1.m6 run, eval=FALSE, message=FALSE, warning=FALSE}

h1.m6 <- brm(Eff ~ 1 + CommAtt + Modality + Big5 + Familiarity + Expressibility_z +  (1 + CommAtt || Participant) + (1 + CommAtt || Concept) + (1 || TrialNumber_c), 
                data = final_data,
                family = lognormal(),
                iter = 4000,
                cores = 4)


# Add criterions for later diagnostics
h1.m6 <- add_criterion(h1.m6, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h1.m6_R2 <- bayes_R2(h1.m6)

# Save both as objects
saveRDS(h1.m6, here("09_Analysis_Modeling", "models", "h1.m6.rds"))
saveRDS(h1.m6_R2, here("09_Analysis_Modeling", "models", "h1.m6_R2.rds"))

beep(5)


```

```{r h1.m6 sum, message=FALSE, warning=FALSE}

h1.m6 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m6.rds"))
h1.m6_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m6_R2.rds"))


# Summary
summary(h1.m6)
# Coefficients remain mostly unchanged 


```

### Converting to original scale

Of course now we have all on lognormal scale so it is not so straightforwadly interpretable. This is how we can get to the values of an effort under certain value of a predictor

```{r h1.m6 converting, message=FALSE, warning=FALSE}

# Compute estimated marginal means on log-scale
em_h1.m6 <- emmeans(h1.m6, ~ CommAtt) #~ CommAtt

#Backtransform the post.beta values
em_h1.m6@post.beta <- exp(em_h1.m6@post.beta)
print(em_h1.m6)

```

So we indeed see that effort in CommAtt2 increase but then decreases again for CommAtt3. We can also try to get our simulated betas

```{r h1.m6 converting2, message=FALSE, warning=FALSE}

coeff1 <- 3.33*1.5 
coeff2 <- 3.33*0.5

print(coeff1)
print(coeff2) # which is very close to the mean values we see from the model
```

We see that the effect estimated by the model is now stronger than in our simulated data. However, note that these values are averaged over predictor modality

We can also try a different method to get the coefficients (code adapted from [here](https://bruno.nicenboim.me/bayescogsci/ch-reg.html#sec-trial))

```{r h1.m6 converting3, message=FALSE, warning=FALSE}

# Extract posterior samples
alpha_samples <- as_draws_df(h1.m6)$b_Intercept
beta_2_vs_1 <- as_draws_df(h1.m6)$b_CommAtt2M1
beta_3_vs_2 <- as_draws_df(h1.m6)$b_CommAtt3M2

# Compute expected values on the log scale
mu_1 <- alpha_samples  # CommAtt 1
mu_2 <- alpha_samples + beta_2_vs_1  # CommAtt 2
mu_3 <- alpha_samples + beta_2_vs_1 + beta_3_vs_2  # CommAtt 3

# Transform to original scale
effect_1 <- exp(mu_1)
effect_2 <- exp(mu_2)
effect_3 <- exp(mu_3)

# Calculate contrasts on the original scale
effect_diff_2_vs_1 <- effect_2 - effect_1
effect_diff_3_vs_2 <- effect_3 - effect_2
effect_diff_3_vs_1 <- effect_3 - effect_1

# Summarize the effects
list(
  mean_intercept = mean(effect_1),
  mean_diff_2_vs_1 = c(mean = mean(effect_diff_2_vs_1), quantile(effect_diff_2_vs_1, c(0.025, 0.975))),
  mean_diff_3_vs_2 = c(mean = mean(effect_diff_3_vs_2), quantile(effect_diff_3_vs_2, c(0.025, 0.975))),
  mean_diff_3_vs_1 = c(mean = mean(effect_diff_3_vs_1), quantile(effect_diff_3_vs_1, c(0.025, 0.975)))
)

```

Now we can use these coefficients to transform to our simulated betas

```{r h1.m6 converting4, message=FALSE, warning=FALSE}

h1m6_coeff <- transform_attempt(3.419549, 2.950688, -4.240333)
print(h1m6_coeff)

```

Now this looks closer again to our betas.

This code does the same for all predictors (except concept and participant)

```{r h1.m6 converting5, message=FALSE, warning=FALSE}

# Extract posterior samples
posterior_samples <- as_draws_df(h1.m6)
alpha_samples <- posterior_samples$b_Intercept

# Create a list to store effects for each fixed factor
effect_list <- list()

# Helper function to calculate summary statistics
get_effect_summary <- function(effect_samples) {
  mean_effect <- mean(effect_samples)
  se_effect <- sd(effect_samples)
  ci_effect <- quantile(effect_samples, c(0.025, 0.975))
  post_prob <- mean(effect_samples > 0)
  c(mean = mean_effect, 
    se = se_effect, 
    lower_ci = ci_effect[1], 
    upper_ci = ci_effect[2], 
    post_prob = post_prob)
}

# COMMATT (successive differences coding)
if ("b_CommAtt2M1" %in% colnames(posterior_samples) & "b_CommAtt3M2" %in% colnames(posterior_samples)) {
  beta_2_vs_1 <- posterior_samples$b_CommAtt2M1
  beta_3_vs_2 <- posterior_samples$b_CommAtt3M2
  
  mu_1 <- alpha_samples
  mu_2 <- alpha_samples + beta_2_vs_1
  mu_3 <- alpha_samples + beta_2_vs_1 + beta_3_vs_2
  
  effect_list$CommAtt <- rbind(
    "commat 2 vs 1" = get_effect_summary(exp(mu_2) - exp(mu_1)),
    "commat 3 vs 2" = get_effect_summary(exp(mu_3) - exp(mu_2)),
    "commat 3 vs 1" = get_effect_summary(exp(mu_3) - exp(mu_1))
  )
}

# MODALITY (sum contrasts scaled by 0.5)
if ("b_Modality1" %in% colnames(posterior_samples) & "b_Modality2" %in% colnames(posterior_samples)) {
  beta_mod_1 <- posterior_samples$b_Modality1
  beta_mod_2 <- posterior_samples$b_Modality2
  
  mu_mod_1 <- alpha_samples + beta_mod_1
  mu_mod_2 <- alpha_samples + beta_mod_2
  mu_mod_3 <- alpha_samples - beta_mod_1 - beta_mod_2
  
  effect_list$Modality <- rbind(
    "mod 1 vs 2" = get_effect_summary(exp(mu_mod_1) - exp(mu_mod_2)),
    "mod 1 vs 3" = get_effect_summary(exp(mu_mod_1) - exp(mu_mod_3)),
    "mod 2 vs 3" = get_effect_summary(exp(mu_mod_2) - exp(mu_mod_3))
  )
}

# BIG5 (continuous)
if ("b_Big5" %in% colnames(posterior_samples)) {
  beta_big5 <- posterior_samples$b_Big5
  effect_list$Big5 <- get_effect_summary(exp(alpha_samples + beta_big5) - exp(alpha_samples))
}

# FAMILIARITY (continuous)
if ("b_Familiarity" %in% colnames(posterior_samples)) {
  beta_fam <- posterior_samples$b_Familiarity
  effect_list$Familiarity <- get_effect_summary(exp(alpha_samples + beta_fam) - exp(alpha_samples))
}

# EXPRESSIBILITY_Z (continuous)
if ("b_Expressibility_z" %in% colnames(posterior_samples)) {
  beta_expr <- posterior_samples$b_Expressibility_z
  effect_list$Expressibility_z <- get_effect_summary(exp(alpha_samples + beta_expr) - exp(alpha_samples))
}

# TRIAL NUMBER (centered continuous)
if ("b_TrialNumber_c" %in% colnames(posterior_samples)) {
  beta_trial <- posterior_samples$b_TrialNumber_c
  effect_list$TrialNumber_c <- get_effect_summary(exp(alpha_samples + beta_trial) - exp(alpha_samples))
}

# Convert to a nicely formatted data frame
effect_df <- do.call(rbind, effect_list)

# View effects
effect_df

```

So here we also see the negative effect of combined modality (mod1)

Now we can also check some visual diagnostics.

```{r h1.m6 check, message=FALSE, warning=FALSE}

plot(h1.m6)
# all good

plot(conditional_effects(h1.m6), points = TRUE)
# the effects all go in good direction

pp_check(h1.m6, type = "dens_overlay")
# we got rid of negative predictions, and it looks very good

pp_check(h1.m6, type = "error_scatter_avg")
# very nice blob

h1.m6_R2
# explained variance increases to 88%

```

## Model 6.1 - with correlation

Since we now significantly improved the model performance, let's try once again the correlation between slope and intercept

```{r h1.m6c run, eval=FALSE, message=FALSE, warning=FALSE}


h1.m6c <- brm(Eff ~ 1 + CommAtt + Modality + Big5 + Familiarity + Expressibility_z +  (1 + CommAtt | Participant) + (1 + CommAtt | Concept) + (1 | TrialNumber_c), 
                data = final_data,
                family = lognormal(),
                iter = 4000,
                cores = 4)


# Add criterions for later diagnostics
h1.m6c <- add_criterion(h1.m6c, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h1.m6c_R2 <- bayes_R2(h1.m6c)

# Save both as objects
saveRDS(h1.m6c, here("09_Analysis_Modeling", "models", "h1.m6c.rds"))
saveRDS(h1.m6c_R2, here("09_Analysis_Modeling", "models", "h1.m6c_R2.rds"))

beep(5)


```

```{r h1.m6c sum, message=FALSE, warning=FALSE}

h1.m6c <- readRDS(here("09_Analysis_Modeling", "models", "h1.m6c.rds"))
h1.m6c_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m6c_R2.rds"))


# Summary
summary(h1.m6c)
# Coefficients remain mostly unchanged 


```

```{r h1.m6c check, message=FALSE, warning=FALSE}

plot(h1.m6c)
# now correlation does not seem to generate problems

plot(conditional_effects(h1.m6c), points = TRUE)
# the effects all go in good direction

pp_check(h1.m6c, type = "dens_overlay")
# ppcheck good

pp_check(h1.m6c, type = "error_scatter_avg")
# nice blob

h1.m6c_R2
# explained variance remains around 88%

```

## Diagnostics I

We now have several models that we can test for predictive performance.

```{r h1 diagnostics I, include=FALSE, message=FALSE, warning=FALSE}

model_list <- list(h1.m1, h1.m2, h1.m3, h1.m3p, h1.m4, h1.m5, h1.m6, h1.m6c)

r2_list <- list(h1.m1_R2, h1.m2_R2, h1.m3_R2, h1.m3p_R2, h1.m4_R2, h1.m5_R2, h1.m6_R2, h1.m6c_R2)

```

### Rhat

Rhat tells us whether the model's Markov chains have converged—values close to 1 mean the model has likely converged well.

```{r h1 rhat I, message=FALSE, warning=FALSE}

# Extract R-hat values for each model
rhat_list <- lapply(model_list, function(model) {
  rhat_values <- rhat(model)
  data.frame(model = deparse(substitute(model)), 
             max_rhat = max(rhat_values), 
             min_rhat = min(rhat_values))
})

# Combine and inspect
do.call(rbind, rhat_list)

```

All models seems actually ok in terms of Rhat values except model 2 (h1.m2)

### ESS

Effective sample size tells how many independent samples the model has effectively drawn from the PD. Low ESS suggests autocorrelation (i.e., sample explores one part of posterior), while high ESS means good mix

```{r h1 ess I, message=FALSE, warning=FALSE}

# Extract n_eff values for each model
neff_ratio_list <- lapply(model_list, function(model) {
  neff_values <- neff_ratio(model)              # Here we calculate ratio (not the raw number of effective samples)
  data.frame(model = deparse(substitute(model)), 
             min_neff = min(neff_values), 
             max_neff = max(neff_values),
             mean_neff = mean(neff_values))
               
})

# Combine and inspect
do.call(rbind, neff_ratio_list)

```

So the highest ratio have model h1.m6c (lognormal with correlation) but in fact they are all quite comparable. Let's loot at 3 highest

```{r h1 ess I.I, message=FALSE, warning=FALSE}

effective_sample(h1.m6c) # this one indeed seems the best as it has all ESS around 10k
effective_sample(h1.m6)
effective_sample(h1.m3p) 

```

So there are some considerable differences for different coefficients

### LOO & WAIC

Leave-One-Out (LOO) validation is a technique where, for each iteration, one data point is left out as the test set, and the model is trained on the remaining data points; this process is repeated for each data point, and the model's overall performance is averaged over all iterations.

```{r h1 loo I, message=FALSE, warning=FALSE}

l <- loo_compare(h1.m1, h1.m2, h1.m3, h1.m3p, h1.m4, h1.m5, h1.m6, h1.m6c, criterion = "loo")

print(l, simplify = F)

```

::: callout-note
elpd_loo: This is the expected log pointwise predictive density for LOO. Higher values indicate a better fit to the data.

se_elpd_loo: The standard error of the elpd_loo, representing uncertainty in the model’s predictive fit according to LOO.

looic: The LOO Information Criterion, which is similar to waic but based on leave-one-out cross-validation. Lower values are better.

p_loo: The effective number of parameters according to LOO, indicating the model’s complexity.

se_p_loo: The standard error of p_loo, representing uncertainty around the effective number of parameters.
:::

Model with lognormal distribution seems the best as assessed by LOO.

```{r h1 waic I, message=FALSE, warning=FALSE}

w <- loo_compare(h1.m1, h1.m2, h1.m3, h1.m3p, h1.m4, h1.m5, h1.m6, h1.m6c, criterion = "waic")

print(w, simplify = F)

# see Solomon Kurz
cbind(waic_diff = w[,1] * -2,
      se = w[,2] * 2)

```

::: callout-note
elpd_waic (expected log pointwise predictive density for WAIC): This represents the model's predictive fit to the data. Higher values indicate a better fit.

se_elpd_waic (standard error of elpd_waic): Measures uncertainty around the elpd_waic estimate.

waic: The Widely Applicable Information Criterion, a measure of model fit where lower values indicate a better fit.

se_waic (standard error of WAIC): Uncertainty around the WAIC estimate.

elpd_diff: The difference in the elpd_waic between the model in question and the baseline model (fit_eff_2, which has elpd_diff of 0). A negative value indicates that the model fits worse than fit_eff_2.

se_diff: The standard error of the elpd_diff, indicating how much uncertainty there is in the difference in predictive performance.

p_waic: The number of effective parameters in the model (related to model complexity). Lower values indicate simpler models, and higher values suggest more complexity.
:::

Plot the comparison

```{r h1 waic plot, echo=FALSE, message=FALSE, warning=FALSE}

w[, 7:8] %>% 
  data.frame() %>% 
  rownames_to_column("model_name") %>% 
  mutate(model_name = fct_reorder(model_name, waic, .desc = T)) %>% 
  
  ggplot(aes(x = waic, y = model_name, 
             xmin = waic - se_waic, 
             xmax = waic + se_waic)) +
  geom_pointrange(color = carto_pal(7, "BurgYl")[7], 
                  fill = carto_pal(7, "BurgYl")[5], shape = 21) +
  labs(title = "WAIC plot",
       x = NULL, y = NULL) +
  theme(axis.ticks.y = element_blank())

```

```{r h1 weights, message=FALSE, warning=FALSE}

model_weights(h1.m1, h1.m2, h1.m3, h1.m3p, h1.m4, h1.m5, h1.m6, h1.m6c, weights = "waic") %>% 
  round(digits = 2)

```

So as ppcheck already suggested, lognormal model indeed seem to have the most predictive power. For this particular (synthetic) data, we will now proceed with model h1.m6c

We will first add some mildly informative priors, and then we also try to add some interaction terms and do a comparison once again.

## Model 7 - lognormal with priors

Let's first check what priors have been selected as default for h1.m6c

```{r h1.m7 priors, message=FALSE, warning=FALSE}

# Print priors
prior_summary(h1.m6c)

```

Wee can keep all defaulted ones, but we do not need to leave flat priors for the beta coefficients as we do have some assumptions/expectations

Let's reuse priors we have already used for h1.m3p

```{r h1.m7 run, eval=FALSE, message=FALSE, warning=FALSE}

priors_h1m7 <- c(
  set_prior("normal(2.5, 0.5)", class = "Intercept", lb=0),
  set_prior("normal(0,0.50)", class = "b", coef = "CommAtt2M1"),
  set_prior("normal(0,0.50)", class = "b", coef = "CommAtt3M2"),
  set_prior("normal(0,0.25)", class = "b", coef = "Modality1"),
  set_prior("normal(0,0.25)", class = "b", coef = "Modality2"),
  set_prior("normal(0,0.25)", class = "b", coef = "Big5"),
  set_prior("normal(0,0.25)", class = "b", coef = "Familiarity"),
  set_prior("normal(0,0.25)", class = "b", coef = "Expressibility_z")
)

# The rest we will leave default (and check afterwards)
h1.m7 <- brm(Eff ~ 1 + CommAtt + Modality + Big5 + Familiarity + Expressibility_z +  (1 + CommAtt | Participant) + (1 + CommAtt | Concept) + (1 | TrialNumber_c), 
                data = final_data,
                family = lognormal(),
                prior = priors_h1m7,
                iter = 4000,
                cores = 4)


# Add criterions for later diagnostics
h1.m7 <- add_criterion(h1.m7, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h1.m7_R2 <- bayes_R2(h1.m7)

# Save both as objects
saveRDS(h1.m7, here("09_Analysis_Modeling", "models", "h1.m7.rds"))
saveRDS(h1.m7_R2, here("09_Analysis_Modeling", "models", "h1.m7_R2.rds"))

beep(5)


```

```{r h1.m7 sum, message=FALSE, warning=FALSE}

h1.m7 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m7.rds"))
h1.m7_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m7_R2.rds"))

# Summary
summary(h1.m7)
# Coefficients remain mostly unchanged 

```

```{r h1.m7 check, message=FALSE, warning=FALSE}

plot(h1.m7)
# all good

plot(conditional_effects(h1.m7), points = TRUE)
# the effects all go in good direction

pp_check(h1.m7, type = "dens_overlay")
# nice

pp_check(h1.m7, type = "error_scatter_avg")
# unchanged

h1.m7_R2
# explained variance remains around 88%

```

Let's now also check whether the priors make sense

```{r h1.m7 ppd check, echo=FALSE, message=FALSE, warning=FALSE}

pp_check(h1.m7,
         type = "stat",
         stat = "mean",
         bins = 50,
         prefix = "ppd") +
  coord_cartesian(xlim = c(-10, 10)) +
  ggtitle("Prior predictive distribution of means")
# this look okay

pp_check(h1.m7,
         type = "stat",
         stat = "min",
         prefix = "ppd") +
  coord_cartesian(xlim = c(-15, 10)) +
  ggtitle("Prior predictive distribution of minimal values")
# this looks good

pp_check(h1.m7,
         type = "stat",
         stat = "max",
         prefix = "ppd") +
  coord_cartesian(xlim = c(-10, 15)) +
  ggtitle("Prior predictive distribution of maximal values")
# this too looks reasonable

```

## Model 8 - adding interactions

Possible interactions include:

-   CommAtt x Modality - Effort could increase differently across modalities, depending on whether concept is guessed on the first, second or third attempt. E.g., gesture might require more effort on initial attempt, but vocal require more effort in repeated attempt. This is interesting question and it would help disentangle the benfit of multimodality over unimodality (i.e., multimodal trials might be more effortful, but overal have less attempts). However, we already model effect of modality on effort, so maybe this is not top priority.

-   CommAtt x Expressibility - Higher expressibility should moderate the effect of repeated attempts, such that the increase in effort with each additional attempt is smaller (or bigger?) for more expressible concepts.This is not a priority for our analysis.

-   Modality × Expressibility_z - The influence of expressibility on effort could be modality-specific — perhaps effort increases less with expressibility in the combined modality. For our analysis, this is also not a priority (especially since expressibiliy has already modality encoded)

-   Familiarity x CommAtt - More familiar partners may guess faster (fewer attempts) and require less effort, but this effect could diminish over multiple attempts. For our analysis, this is not a priority,

-   Big5 × Modality or Big5 × CommAtt - More open/extraverted participants might maintain higher effort over attempts, or adjust more dynamically depending on the communicative channel. While not priority, it is an interesting question if we want to tap more into the inter-individual variability.

Let's try CommAtt x Modality and Big5 x CommAtt

```{r h1.m8 run, eval=FALSE, message=FALSE, warning=FALSE}

h1.m8 <- brm(Eff ~ 1 + CommAtt * Modality + Big5 * CommAtt + Familiarity + Expressibility_z +  (1 + CommAtt | Participant) + (1 + CommAtt | Concept) + (1 | TrialNumber_c), 
                data = final_data,
                family = lognormal(),
                prior = priors_h1m7, # we keep the priors from previous model
                iter = 4000,
                cores = 4)


# Add criterions for later diagnostics
h1.m8 <- add_criterion(h1.m8, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h1.m8_R2 <- bayes_R2(h1.m8)

# Save both as objects
saveRDS(h1.m8, here("09_Analysis_Modeling", "models", "h1.m8.rds"))
saveRDS(h1.m8_R2, here("09_Analysis_Modeling", "models", "h1.m8_R2.rds"))

beep(5)


```

```{r h1.m8 sum, message=FALSE, warning=FALSE}

h1.m8 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m8.rds"))
h1.m8_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h1.m8_R2.rds"))


# Summary
summary(h1.m8)
# Coefficients remain mostly unchanged 
# Since we did not really focused on the interactions during the simulation, we also don't have strong expectations here. But for the real data, there is a good reason to expect some meaningful values

```

```{r h1.m8 check, message=FALSE, warning=FALSE}

plot(h1.m8)
# all good

plot(conditional_effects(h1.m8), points = TRUE)
# the effects all go in good direction
# we can see here that combined modality remains moderated across all commatts
# and also big5 seems to matter the most in the second attempt

pp_check(h1.m8, type = "dens_overlay")
# the problem with predicting negative values remains

pp_check(h1.m8, type = "error_scatter_avg")
# unchanged

h1.m8_R2
# explained variance remains around 87%

```

## Diagnostics II

### ESS

```{r h1 ess II, message=FALSE, warning=FALSE}

effective_sample(h1.m6) 
effective_sample(h1.m6c)
effective_sample(h1.m7) 
effective_sample(h1.m8) 

# Now h1m6 looks as the weakest, while h1m8 looks much better - but ESS for Intercept is for some reason still quite low

```

### LOO & WAIC

```{r h1 loo II, message=FALSE, warning=FALSE}

l <- loo_compare(h1.m6, h1.m6c, h1.m7, h1.m8, criterion = "loo")

print(l, simplify = F)

```

```{r h1 waic II, message=FALSE, warning=FALSE}

w <- loo_compare(h1.m6, h1.m6c, h1.m7, h1.m8, criterion = "waic")

print(w, simplify = F)

# see Solomon Kurz
cbind(waic_diff = w[,1] * -2,
      se = w[,2] * 2)

```

So in terms of WAIC & LOO, interactions do not really add predictive power. This might be specific for the synthetic data, as we did not explicitly focused on the interaction coefficients there. At the same time, the difference of h1.m8 from h1.m6c is not so significant. For now, we stop here. With the full data, we will proceed with the same evaluation.

# H2: Modelling

Now we can need to account also for our second hypothesis, namely

*H2: A higher degree of misunderstanding will require a performer to engage in more effortful correction.*

We operationalize degree of misunderstanding as a cosine similarity of performer's target and guesser's answer (PrevAn). The difficulty with our data structure is that PrevAn is a variable that has values only for second and third correction (i.e., there is no previous answer for the first performance). If we left it unchange, the model will eventually get rid of all NA values, which means we will loose the relationship between effort in second and first communicative attempt. To avoid this, we will create a new variable which we call *Effort Change*. We will simply calculate the change from effort in communicative attempt x to communicative attempt x+1. We will still loose communicative attempt 1, but the change that will be associated with CommAtt==2 already encapsulates the relationship towards this attempt.

```{r h2 loading data, message=FALSE, warning=FALSE, include=FALSE}

# load our data back if we lost them
final_data <- read_csv(paste0(datasets, "synthetic_data.csv"))

```

## Data wrangling I

```{r effort change ratio, message=FALSE, warning=FALSE}

# Calculate Effort Change (Difference)
final_data_2 <- final_data %>%
  group_by(Participant, Concept) %>%
  mutate(
    Effort_1 = Eff[CommAtt == 1][1],  # Effort for attempt 1
    Effort_2 = Eff[CommAtt == 2][1],  # Effort for attempt 2
    Effort_3 = Eff[CommAtt == 3][1],  # Effort for attempt 3
    Effort_Change_1_to_2 = case_when(
      CommAtt == 2 & !is.na(Effort_1) ~ Eff - Effort_1,  # Change from 1st to 2nd attempt
      TRUE ~ NA_real_
    ),
    Effort_Change_2_to_3 = case_when(
      CommAtt == 3 & !is.na(Effort_2) ~ Eff - Effort_2,  # Change from 2nd to 3rd attempt
      TRUE ~ NA_real_
    )
  ) %>%
  ungroup()

# Collide changes into a single column
final_data_2 <- final_data_2 %>%
  mutate(
    Effort_Change = coalesce(Effort_Change_1_to_2, Effort_Change_2_to_3)
  ) 

# Remove unnecessary columns
final_data_2 <- subset(final_data_2, select = -c(Effort_1, Effort_2, Effort_3, Effort_Change_1_to_2, Effort_Change_2_to_3)) 

# View the result
head(final_data_2, n=15)

```

## Exploring structure

This is the relationship between effort and answer similarity (H2) as seen in the raw (synthetic) data

```{r h2 plot, message=FALSE, warning=FALSE, echo=FALSE}

# Filter out CommAtt == 1
filtered_data <- final_data_2[final_data_2$CommAtt != 1, ]

ggplot(filtered_data, aes(x = PrevAn, y = Eff)) +
  geom_point(alpha = 0.6, color = "blue") +  # Scatter points
  geom_smooth(method = "lm", color = "red", se = FALSE) +  # Regression line
  labs(x = "Previous Answer Similarity (PrevAn)", 
       y = "Effort (Eff)", 
       title = "Relationship between Effort and Previous Answer Similarity") +
  theme_minimal()

```

```{r h2 plot 2, message=FALSE, warning=FALSE, echo=FALSE}

ggplot(filtered_data, aes(x = PrevAn, y = Effort_Change)) +
  geom_point(alpha = 0.6, color = "blue") +  # Scatter points
  geom_smooth(method = "lm", color = "red", se = FALSE) +  # Regression line
  labs(x = "Previous Answer Similarity (PrevAn)", 
       y = "Effort (Eff)", 
       title = "Relationship between Effort Change and Previous Answer Similarity") +
  theme_minimal()

```

This is how effort change is distributed

```{r h2 hist, message=FALSE, warning=FALSE, echo=FALSE}

hist(filtered_data$Effort_Change, breaks=100)

```

So we will have to work with bimodal distribution, as we either have a decrease in effort or increase

# H2: Stating causal model

We now also need a new DAG. Essentially, what we said will influence CommAtt in H1, will now also influence PrevAn because they are tightly related. For instance, more extroverted people can be expected to be better guessers, therefore the similarity of the previous answer will be higher.

```{r dag h2, message=FALSE, warning=FALSE, echo=FALSE}

daggy_h2 <- dagitty('dag {
EffChange [outcome,pos="0,0"]
PrevAn [exposure,pos="-2,0"]
Big5 [pos="-1.5,1"]
CommAtt [pos="0,-1.5"]
Conc [pos="-2,-1.5"]
Expr [pos="-1.5,-1.5"]
Fam [pos="-0.5,1"]
Pcn [pos="-1,2"]
TrNum [pos="-2.5,-1.5"]
Mod [pos="-1,0.5"]

Big5 -> PrevAn     
Big5 -> EffChange
CommAtt -> EffChange
Conc -> Expr
Expr -> PrevAn
Expr -> EffChange
Fam -> PrevAn
Fam -> EffChange
Mod -> EffChange
Mod -> PrevAn
Pcn -> Big5
Pcn -> PrevAn 
Pcn -> EffChange
Pcn -> Fam
TrNum -> PrevAn
TrNum -> EffChange
Conc -> PrevAn
Conc -> EffChange
PrevAn -> EffChange
PrevAn -> CommAtt
}')

# Use ggdag for a cleaner visualization
d2 <- ggdag(daggy_h2, text = TRUE, use_labels = "name") +
  theme_dag() +
  ggtitle("Causal DAG for Effort Change") +
  theme(plot.title = element_text(hjust = 0.5))

d2

```

```{r dag h2 adjustset, message=FALSE, warning=FALSE, echo=TRUE}

dagitty::adjustmentSets(daggy_h2, exposure = "PrevAn", outcome = "EffChange")

```

The adjustment set is identical to the one of H1. Note that we are here omitting arrows going from all these variables to ComAtt. Since PrevAn affects CommAtt, and not the other way, we do not need to block this path to avoid confounds. However, if we want to asses direct effect of PrevAn on EffChange, we have to add CommAtt to the model as well.

# H2: Modelling

Converting columns to factors

```{r h2 factorizing, message=FALSE, warning=FALSE}

filtered_data$CommAtt <- as.factor(filtered_data$CommAtt)
filtered_data$CommAtt <- droplevels(filtered_data$CommAtt) # commatt1 still remains as a level
filtered_data$CommAtt <- as.factor(filtered_data$CommAtt) # redo again
filtered_data$Modality <- as.factor(filtered_data$Modality)
filtered_data$Participant <- as.factor(filtered_data$Participant)
filtered_data$Concept <- as.factor(filtered_data$Concept)

filtered_data$TrialNumber <- as.numeric(filtered_data$TrialNumber)  # Ensure TrialNumber is numeric
```

Contrast-coding for categorical predictors

```{r h2 contrastcoding, message=FALSE, warning=FALSE}

contrasts(filtered_data$CommAtt) <- contr.sum(2)/1
contrasts(filtered_data$Modality) <- contr.sum(3)/2
```

Centering continuous predictors

```{r h2 centering, message=FALSE, warning=FALSE}

filtered_data$TrialNumber_c <- filtered_data$TrialNumber - median(range(filtered_data$TrialNumber))
filtered_data$Familiarity <- filtered_data$Familiarity - median(range(filtered_data$Familiarity))
filtered_data$Big5 <- filtered_data$Big5 - median(range(filtered_data$Big5))


```

Z-scoring expressibility and similarity (PrevAn)

```{r h2 zscoring, message=FALSE, warning=FALSE}

filtered_data <-
  filtered_data |>
  group_by(Modality) |>
  mutate(Expressibility_z = (Expressibility - mean(Expressibility))/ sd(filtered_data$Expressibility, na.rm = T)) |>
  ungroup()

filtered_data <-
  filtered_data |>
  mutate(PrevAn_z = (PrevAn - mean(PrevAn))/ sd(filtered_data$PrevAn, na.rm = T)) |>
  ungroup()

```

<!-- z-scoring -->

Note: maybe we should center where we z-score to get better sense of the predictors (right now, for me it's still a bit uninterpretable)

<!-- z-scoring -->

```{r centering instead of zscoring, include=FALSE, message=FALSE, warning=FALSE}

# To test, we will also center both expressibility and prevan to see what offers better interpretation

filtered_data$PrevAn_c <- filtered_data$PrevAn - median(range(filtered_data$PrevAn))

filtered_data <- 
  filtered_data |>
  group_by(Modality) |>
  mutate(Expressibility_c = Expressibility - median(range(Expressibility))) |>
  ungroup()

```

## Model 1 - DAG

Similarly to H1, we will start with reproducing the DAG for H2

```{r h2.m1 run, eval=FALSE, message=FALSE, warning=FALSE}

h2.m1 <- brm(Effort_Change ~ 1 + PrevAn_z + CommAtt + Familiarity + Big5 + Expressibility_z + TrialNumber_c + Modality + (1 | Participant) + (1 | Concept),
                data = filtered_data,
                iter = 4000,
                cores = 4)

# Add criterions for later diagnostics
h2.m1 <- add_criterion(h2.m1, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h2.m1_R2 <- bayes_R2(h2.m1)

# Save both as objects
saveRDS(h2.m1, here("09_Analysis_Modeling", "models", "h2.m1.rds"))
saveRDS(h2.m1_R2, here("09_Analysis_Modeling", "models", "h2.m1_R2.rds"))

beep(5)

```

```{r h2.m1 sum, message=FALSE, warning=FALSE}

h2.m1 <- readRDS(here("09_Analysis_Modeling", "models", "h2.m1.rds"))
h2.m1_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h2.m1_R2.rds"))


# Summary
summary(h2.m1)
# coefficients seem quite conservative, even for PrevAn (but remember, it's z-scored)

```

```{r h2.m1 check, message=FALSE, warning=FALSE}

plot(h2.m1)
# all looks ok

plot(conditional_effects(h2.m1), points = TRUE)
# the main effect seems ok, the rest of the predictors does not show nothing (maybe because of the transformation we lost the relations between them and the effort)

pp_check(h2.m1, type = "dens_overlay")
# this looks quite okay-ish

pp_check(h2.m1, type = "error_scatter_avg")
# so there seems to be quite high residual error

h2.m1_R2
# explained variance around 89%

```

We see two modes in the distribution of the predictor. While Gaussian family seems to deal with it well, we could also consider model with mixture of two Gaussian distributions. This will allow each mode to have their own mean and variance. With effort change being distributed over positive as well as negative values, lognormal distribution is not applicable.

Importantly, there are some diagnostics we should be cautious about - the relationship between predicted values and residual error is quite correlated.

Also notice the high explained variance indicated by R\^2. In real case, this would be almost pointing to over-fitting issues. However, we created synthetic data that does not contain as much noise as we can expect from the real data, so it is quite likely that if we simply used all predictors we know to cause a variance here, we might be explaining most of the variation. It is quite likely this will not be the case for real data.

## Splines 1 - fitting b-splines

In the previous model for H1, we were able to spot possible non-linear trends by contrast coding of the communicative attempts whereby each level was defined relative to the two remaining. Now, we are dealing with situation where both outcome variable and the main predictor are continuous variable. Also here we might expect nonlinear patterns in their relationship. For instance, it might be the case that for answers that are completely off, people do not feel motivated to put in more effort, and some kind of sensible 'threshold' needs to be reached for the effort to increase to resolve misunderstanding, and then again decrease when the answer is very similar.

We will use a combination of B-splines and Bayesian GAMs to prepare some models and try them fit to the synthetic data. However, note that we currently do not expect any non-linearity as we have not coded any within the simulation, as seen in the following plot fitted with loess method.

```{r h2 plot nonlinear, echo=FALSE, message=FALSE, warning=FALSE}

ggplot(filtered_data, aes(x = PrevAn, y = Eff)) +
  geom_point(alpha = 0.6, color = "blue") +  # Scatter points
  geom_smooth(method = "loess", color = "red", se = FALSE) +  # loess for potential nonlinearity
  labs(x = "Previous Answer Similarity (PrevAn)", 
       y = "Effort (Eff)", 
       title = "Relationship between Effort and Previous Answer Similarity") +
  theme_minimal()

```

B-splines allow to build up wiggly functions from more simple components which are called 'basis functions' (B). They divide a full range of predictor into parts and assign a parameter to each part. The parameters are gradually turned on and off in a way that makes their sum into a curve. Unlike polynomial regression, b-splines do not transform predictor, but they invent a series of new synthetic predictor variables. Each of them then exists only to gradually turn a specific parameter on and off within a specific range of the real predictor variable. Each of these synthetic variables is called a basis function B. See more in Richard McElreath's Statistical Rethinking (@ADDREF).

We are using the [code](https://bookdown.org/content/4857/geocentric-models.html) from Solomon Kurz's adaptation of this book.

```{r h2 datawrangle, message=FALSE, warning=FALSE}

# Get rid of NAs in the predictor
d <-
  final_data_2 %>% 
  drop_na(PrevAn)

# And convert all that is necessary to factor/numerical
d$CommAtt <- as.factor(d$CommAtt)
d$Modality <- as.factor(d$Modality)
d$Participant <- as.factor(d$Participant)
d$Concept <- as.factor(d$Concept)
d$TrialNumber <- as.numeric(d$TrialNumber) 

```

Here we can see summary of each predictor

```{r h2 datawrangle 2, message=FALSE, warning=FALSE}

d %>% 
  select_if(is.numeric) %>%  # Select only numeric columns
  pivot_longer(cols = everything(), names_to = "key", values_to = "value") %>%
  group_by(key) %>%
  summarise(
    mean = mean(value, na.rm = TRUE),
    sd   = sd(value, na.rm = TRUE),
    ll   = quantile(value, probs = 0.055, na.rm = TRUE),
    ul   = quantile(value, probs = 0.945, na.rm = TRUE)
  ) %>%
  mutate(across(where(is.double), round, digits = 2))

head(d, n=10)

```

Now we need to specify knots that function as pivots for number of different basis functions. The B variable then tells you which knot you are close to.

```{r h2 knots, message=FALSE, warning=FALSE}

num_knots <- 7
knot_list <- quantile(d$PrevAn, probs = seq(from = 0, to = 1, length.out = num_knots))
knot_list

```

Now we can see how we chopped the data by the knots

```{r h2 knot plot, message=FALSE, warning=FALSE, echo=FALSE}

d %>% 
  ggplot(aes(x = PrevAn, y = Effort_Change)) +
  geom_vline(xintercept = knot_list, color = "white", alpha = 1/2) +
  geom_point(color = "#ffb7c5", alpha = 1/2) +
  theme_bw() +
  theme(panel.background = element_rect(fill = "#4f455c"),
        panel.grid = element_blank())

```

Now we need to specify the polynomial degree which determines how parameters interact to produce the spline.

For degree 1, two basis functions combine at each point. For degree 2, three functions combine at each point. For degree 3, four combine.

```{r b-spline, message=FALSE, warning=FALSE}

B <- bs(d$PrevAn,
        knots = knot_list[-c(1, num_knots)], 
        degree = 3, # cubic spline
        intercept = TRUE)

```

This is how cubic spline with 7 knots look like

```{r b-spline plot, message=FALSE, warning=FALSE, echo=FALSE}

# wrangle a bit
b <-
  B %>% 
  data.frame() %>% 
  set_names(str_c(0, 1:4), 5:9) %>%  
  bind_cols(select(d, PrevAn)) %>% 
  pivot_longer(-PrevAn,
               names_to = "bias_function",
               values_to = "bias")

# plot
b %>% 
  ggplot(aes(x = PrevAn, y = bias, group = bias_function)) +
  geom_vline(xintercept = knot_list, color = "white", alpha = 1/2) +
  geom_line(color = "#ffb7c5", alpha = 1/2, linewidth = 1.5) +
  ylab("bias value") +
  theme_bw() +
  theme(panel.background = element_rect(fill = "#4f455c"),
        panel.grid = element_blank())

```

We will now add this B matrix into the data to be able to further use it in the models

```{r b-spline 2, message=FALSE, warning=FALSE}

d2 <-
  d %>% 
  mutate(B = B) 

# take a look at the structure of `d3
d2 %>% glimpse()

```

The B matrix is now a matrix column which contains the same number of rows as the others, but has also 9 columns within that columns. Each of them correspond to one synthetic B variable.

We can now use this matrix to fit our model

```{r h2.s1 run, eval=FALSE, message=FALSE, warning=FALSE}

h2.s1 <- 
  brm(data = d2,
      family = gaussian,
      Effort_Change ~ 1 + B,
      prior = c(prior(normal(100, 10), class = Intercept),
                prior(normal(0, 10), class = b),
                prior(exponential(1), class = sigma)),
      iter = 4000, warmup = 2000, chains = 4, cores = 4,
      seed = 4)


# Add criterions for later diagnostics
h2.s1 <- add_criterion(h2.s1, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h2.s1_R2 <- bayes_R2(h2.s1)

# Save both as objects
saveRDS(h2.s1, here("09_Analysis_Modeling", "models", "h2.s1.rds"))
saveRDS(h2.s1_R2, here("09_Analysis_Modeling", "models", "h2.s1_R2.rds"))

beep(5)

```


```{r h2.s1 sum, message=FALSE, warning=FALSE}

h2.s1 <- readRDS(here("09_Analysis_Modeling", "models", "h2.s1.rds"))
h2.s1_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h2.s1_R2.rds"))

# Summary
print(h2.s1)

```

It's a bit difficult to see what is going on so let's just plot it

```{r h2.s1 plot, message=FALSE, warning=FALSE, echo=FALSE}

post <- as_draws_df(h2.s1)

post %>% 
  select(b_B1:b_B9) %>% 
  set_names(c(str_c(0, 1:4), 5:9)) %>% 
  pivot_longer(everything(), names_to = "bias_function") %>% 
  group_by(bias_function) %>% 
  summarise(weight = mean(value)) %>% 
  full_join(b, by = "bias_function") %>% 
  
  # plot
  ggplot(aes(x = PrevAn, y = bias * weight, group = bias_function)) +
  geom_vline(xintercept = knot_list, color = "white", alpha = 1/2) +
  geom_line(color = "#ffb7c5", alpha = 1/2, linewidth = 1.5) +
  theme_bw() +
  theme(panel.background = element_rect(fill = "#4f455c"),
        panel.grid = element_blank()) 

```

Now with the predictor

```{r h2.s1 plot2, message=FALSE, warning=FALSE, echo=FALSE}

f <- fitted(h2.s1)

f %>% 
  data.frame() %>% 
  bind_cols(d2) %>% 
  
  ggplot(aes(x = PrevAn, y = Effort_Change, ymin = Q2.5, ymax = Q97.5)) + 
  geom_vline(xintercept = knot_list, color = "white", alpha = 1/2) +
  geom_hline(yintercept = fixef(h2.s1)[1, 1], color = "white", linetype = 2) +
  geom_point(color = "#ffb7c5", alpha = 1/2) +
  geom_ribbon(fill = "white", alpha = 2/3) +
  labs(x = "Previous Answer",
       y = "Effort Change") +
  theme_bw() +
  theme(panel.background = element_rect(fill = "#4f455c"),
        panel.grid = element_blank())

```

So as expected, we see quite linear decrease similar to our previous models

Now let's check some diagnostics

```{r h2.s1 check, message=FALSE, warning=FALSE}

plot(h2.s1)
# looks good

pp_check(h2.s1, type = "dens_overlay")
# because we used only main predictor, we can see quite a bad result of the posterior predictive distribution, but we will work on that

pp_check(h2.s1, type = "error_scatter_avg")
# high residual error for both low and high values

h2.s1_R2
# explained variance 2%

```

## Splines 2 - Bayesian GAMs

Now we will use a different workflow, using smooth functions with `brms` package. Brms allow for non-linear models by borrowing functions from `mgcv` package (@ADDREFWood)

This is how priors should look like for one of these functions

```{r h2.s2 priors, message=FALSE, warning=FALSE}

get_prior(data = d2,
          family = gaussian,
          Effort_Change ~ 1 + s(PrevAn))
```

At this point, I will just keep priors at default

```{r h2.s2 run, eval=FALSE, message=FALSE, warning=FALSE}

h2.s2 <-
  brm(data = d2,
      family = gaussian,
      Effort_Change ~ 1 + s(PrevAn, bs = "bs", k = 19),
      iter = 4000, 
      warmup = 2000, 
      chains = 4, 
      cores = 4,
      seed = 4,
      control = list(adapt_delta = .99)
      )

# Add criterions for later diagnostics
h2.s2 <- add_criterion(h2.s2, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h2.s2_R2 <- bayes_R2(h2.s2)

# Save both as objects
saveRDS(h2.s2, here("09_Analysis_Modeling", "models", "h2.s2.rds"))
saveRDS(h2.s2_R2, here("09_Analysis_Modeling", "models", "h2.s2_R2.rds"))


beep(5)

```

Now we can proceed as we usually do

```{r h2.s2 sum, message=FALSE, warning=FALSE}

h2.s2 <- readRDS(here("09_Analysis_Modeling", "models", "h2.s2.rds"))
h2.s2_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h2.s2_R2.rds"))


# Summary
summary(h2.s2)

```

```{r h2.s2 check, message=FALSE, warning=FALSE}

plot(h2.s2)
# looks good

plot(conditional_effects(h2.s2), points = TRUE)
# again, we see similar (non-linear) trend 

pp_check(h2.s2, type = "dens_overlay")
# same as before, ignoring bimodality

pp_check(h2.s2, type = "error_scatter_avg")
# still weird

h2.s2_R2
# explained variance 2%

```

## Splines 3 - GAMs with f+r effects

Now let's use the same model, but adding our other predictors

```{r h2.s3 run, eval=FALSE, message=FALSE, warning=FALSE}

h2.s3 <- 
  brm(
    data = filtered_data,
    family = gaussian,
    Effort_Change ~ 1 +
      s(PrevAn_z, bs = "bs", k = 19) +  # Smooth for Previous Answer similarity
      + CommAtt + Modality + Big5 + Familiarity + Expressibility_z +  # Fixed effects
      (1 | Participant) + (1 | Concept),  # Random effects
    iter = 4000, 
    warmup = 2000, 
    chains = 4, 
    cores = 4,
    seed = 4,
    control = list(adapt_delta = .99)
  )


# Add criterions for later diagnostics
h2.s3 <- add_criterion(h2.s3, criterion = c("loo", "waic"))

# Calculate also variance explained (R^2)
h2.s3_R2 <- bayes_R2(h2.s3)

# Save both as objects
saveRDS(h2.s3, here("09_Analysis_Modeling", "models", "h2.s3.rds"))
saveRDS(h2.s3_R2, here("09_Analysis_Modeling", "models", "h2.s3_R2.rds"))

beep(5)


```

```{r h2.s3 sum, message=FALSE, warning=FALSE}


h2.s3 <- readRDS(here("09_Analysis_Modeling", "models", "h2.s3.rds"))
h2.s3_R2 <- readRDS(here("09_Analysis_Modeling", "models", "h2.s3_R2.rds"))


# Summary
summary(h2.s3)


```

```{r h2.s3 check, message=FALSE, warning=FALSE}


plot(h2.s3)
# looks ok

plot(conditional_effects(h2.s3), points = TRUE)
# now the ffect of PrevAn looks a bit different because we are back to using z-scored version

pp_check(h2.s3, type = "dens_overlay")
# looks ok but the ppd undershoots the low values and overshoot the high values, similar to the linear regression

pp_check(h2.s3, type = "error_scatter_avg")
# still not what we would like

h2.s3_R2
# 89% variance


```

## Diagnostics I

Before we proceed further, let's do first round of diagnostics

```{r h2 diagnostics, include=FALSE, message=FALSE, warning=FALSE}

model_list <- list(h2.m1, h2.s1, h2.s2, h2.s3)

```

### Rhat

```{r h2 rhat, message=FALSE, warning=FALSE}

# Extract R-hat values for each model
rhat_list <- lapply(model_list, function(model) {
  rhat_values <- rhat(model)
  data.frame(model = deparse(substitute(model)), 
             max_rhat = max(rhat_values), 
             min_rhat = min(rhat_values))
})

# Combine and inspect
do.call(rbind, rhat_list)

```

All Rhat values look good

### ESS

Effective sample size tells how many independent samples the model has effectively drawn from the PD. Low ESS suggests autocorrelation (i.e., sample explores one part of posterior), while high ESS means good mix

```{r h2 ess, message=FALSE, warning=FALSE}

# Extract n_eff values for each model
neff_ratio_list <- lapply(model_list, function(model) {
  neff_values <- neff_ratio(model)              # Here we calculate ratio (not the raw number of effective samples)
  data.frame(model = deparse(substitute(model)), 
             min_neff = min(neff_values), 
             max_neff = max(neff_values),
             mean_neff = mean(neff_values))
               
})

# Combine and inspect
do.call(rbind, neff_ratio_list)

```

They all look good expect the very first non-linear model h2.s1 which is quite expectable since we used only main predictor. Linear regression model and GAMs model have highest ESS.

```{r h2 ess2, message=FALSE, warning=FALSE}

effective_sample(h2.m1) 
effective_sample(h2.s3) 

```

### LOO & WAIC

```{r h2 loo, message=FALSE, warning=FALSE}

l <- loo_compare(h2.m1, h2.s1, h2.s2, h2.s3, criterion = "loo")

print(l, simplify = F)

```

Here again we see that GAM and LR model have best performance assessed by LOO.

```{r h2 waic, message=FALSE, warning=FALSE}

w <- loo_compare(h2.m1, h2.s1, h2.s2, h2.s3, criterion = "waic")

print(w, simplify = F)

# see Solomon Kurz
cbind(waic_diff = w[,1] * -2,
      se = w[,2] * 2)

```

Plot the comparison

```{r h2 waic plot, message=FALSE, warning=FALSE, echo=FALSE}

w[, 7:8] %>% 
  data.frame() %>% 
  rownames_to_column("model_name") %>% 
  mutate(model_name = fct_reorder(model_name, waic, .desc = T)) %>% 
  
  ggplot(aes(x = waic, y = model_name, 
             xmin = waic - se_waic, 
             xmax = waic + se_waic)) +
  geom_pointrange(color = carto_pal(7, "BurgYl")[7], 
                  fill = carto_pal(7, "BurgYl")[5], shape = 21) +
  labs(title = "WAIC plot",
       x = NULL, y = NULL) +
  theme(axis.ticks.y = element_blank())

```

Here we see identical results

```{r h2 weights, message=FALSE, warning=FALSE}

model_weights(h2.m1, h2.s1, h2.s2, h2.s3, weights = "waic") %>% 
  round(digits = 2)

```

For the synthetic data, GAMs are probably adding unnecessary complexity as we are not gaining much more explanatory power. However, we leave it open whether linear or non-linear models will be better suited for the real data, following this pipeline.

## Adding priors

Similarly to H1, we will also set mildly informative priors. Let's check what priors have been selected as default for h2.s3

```{r h2 adding priors, message=FALSE, warning=FALSE}

# Print priors
prior_summary(h2.s3)

```

For the flat priors that have been selected as default, we can re-use our previous priors from H1. The priors could therefore look somewhat like this

```{r h2 adding priors 2, message=FALSE, warning=FALSE}

priors_h2s4 <- c(
  set_prior("normal(0,0.50)", class = "b", coef = "sPrevAn_z_1"),
  set_prior("normal(0,0.50)", class = "b", coef = "CommAtt2M1"),
  set_prior("normal(0,0.25)", class = "b", coef = "Modality1"),
  set_prior("normal(0,0.25)", class = "b", coef = "Modality2"),
  set_prior("normal(0,0.25)", class = "b", coef = "Big5"),
  set_prior("normal(0,0.25)", class = "b", coef = "Familiarity"),
  set_prior("normal(0,0.25)", class = "b", coef = "Expressibility_z")
)

```

## Adding Interactions

Because we are currently already reaching the ceiling of R\^2, we are not going to add more interactions. However, we are not excluding the option of adding few interactions when using the real data. Possible interactions include:

-   PrevAn x Modality - similarity affects the change in effort differently (e.g., vocal might still require more effort)

-   PrevAn x Expressibility - similarity in relation to effort might matter only for highly expressible concepts, and low expressible concepts are difficult to express, so also difficult to exaggerate

-   Familiarity x PrevAn - if the guess is really bad, only very familiar people might be motivated enough to put more effort

-   Big x PrevAn - same like with familiarity

Similar to the workflow adopted in H1 modelling, we would fit two new models, one with priors and one with interactions, and perform another round of diagnostics to see which model seems to have the most predictive power.
